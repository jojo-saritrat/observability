// The OpenTelemetry receiver is used to ingest all incoming trace spans. A label 'otlp_receiver' is added to uniquely
// identify this instance.
// Note that both the instrumented application *and* Beyla use the same receiver to send traces.
otelcol.receiver.otlp "otlp_receiver" {
    // We don't technically need this, but it shows how to change listen address and incoming port.
    // In this case, the Alloy is listening on all available bindable addresses on port 4317 (which is the
    // default OTLP gRPC port) for the OTLP protocol.
    grpc {
        endpoint = "0.0.0.0:4317"
    }
    http { }

    // We define where to send the output of all ingested traces. In this case, to the OpenTelemetry batch processor
    // named 'default'.
    output {
        traces = [
            // Uncomment the next line to generate service graph metrics from the Alloy. By default this is generated
            // by the Tempo component, so be sure to remove the relevant configuration in the `tempo/tempo.yaml` file.
            //otelcol.connector.servicegraph.tracemetrics.input,
            // Uncomment the next line to generate span metrics from the Alloy. By default this is generated
            // by the Tempo component, so be sure to remove the relevant configuration in the `tempo/tempo.yaml` file.
            //otelcol.connector.spanmetrics.tracemetrics.input,
            otelcol.connector.spanlogs.autologging.input,
        ]
    }
}

// The OpenTelemetry spanlog connector processes incoming trace spans and extracts data from them ready
// for logging. This is the equivalent of Grafana Alloy's static automatic_logging pipeline.
otelcol.connector.spanlogs "autologging" {
    // We only want to output a line for each root span (ie. every single trace), and not for every
    // process or span (outputting a line for every span would be extremely verbose).
    spans = false
    roots = true
    processes = false
    // We want to ensure that the following three span attributes are included in the log line, if
    // present.
    span_attributes = [ "http.method", "http.target", "http.status_code" ]

    // Overrides the default key in the log line to be `traceId`, which is then used by Grafana to
    // identify the trace ID for correlation with the Tempo datasource.
    overrides {
        trace_id_key = "traceId"
    }
    // Send to the OpenTelemetry Loki exporter.
    output {
        logs = []
    }
}

// The Spanmetrics Connector will generate RED metrics based on the incoming trace span data.
otelcol.connector.spanmetrics "tracemetrics" {
    // The namespace explicit adds a prefix to all the generated span metrics names.
    // In this case, we'll ensure they match as closely as possible those generated by Tempo.
    namespace = "traces.spanmetrics"

    // Each extra dimension (metrics label) to be added to the generated metrics from matching span attributes. These
    // need to be defined with a name and optionally a default value (in the following cases, we do not want a default
    // value if the span attribute is not present).
    dimension {
        name = "http.method"
    }
    dimension {
        name = "http.target"
    }
    dimension {
        name = "http.status_code"
    }
    dimension {
        name = "service.version"
    }

    // A histogram block must be present, either explicitly defining bucket values or via an exponential block.
    // We do the latter here.
    histogram {
        explicit {
        }
    }

    // The exemplar block is added to ensure we generate exemplars for traces on relevant metric values.
    exemplars {
        enabled = true
    }

    // Generated metrics data is in OTLP format. We send this data to the OpenTelemetry Prometheus exporter to ensure
    // it gets transformed into Prometheus format data.
    output {
        metrics = []
    }
}

// The Servicegraph Connector will generate service graph metrics (edges and nodes) based on incoming trace spans.
otelcol.connector.servicegraph "tracemetrics" {
    // Extra dimensions (metrics labels) to be added to the generated metrics from matching span attributes.
    // For this component, this is defined as an array. There are no default values and the labels will not be generated
    // for missing span attributes.
    dimensions = [
        "http.method",
        "http.target",
        "http.status_code",
        "service.version",
    ]

    // Generated metrics data is in OTLP format. We send this data to the OpenTelemetry Prometheus exporter to ensure
    // it gets transformed into Prometheus format data.
    output {
        metrics = [otelcol.exporter.prometheus.tracemetrics.input]
    }
}

// The OpenTelemetry Prometheus exporter will transform incoming OTLP metrics data into Prometheus format data.
otelcol.exporter.prometheus "tracemetrics" {
    // Forward to our local Prometheus remote writer which will send the metrics to Mimir.
    forward_to = []
}